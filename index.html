<!-- index.html -->
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ø§Ù¾ Chand Ø±ÙˆÛŒ ÙˆØ¨ - Ù…Ø¯Ø±Ù†</title>
  <!-- SweetAlert2 CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <style>
    :root {
      /* Dark Theme Palette */
      --primary-bg: #121212; /* Very dark grey (almost black) */
      --secondary-bg: #1e1e1e; /* Dark grey */
      --text-color: #e0e0e0; /* Light grey for text */
      --text-color-secondary: #b3b3b3; /* Slightly dimmer text */
      --header-bg: linear-gradient(90deg, #0f2027, #203a43, #2c5364); /* Dark blue/grey gradient */
      --header-text: #ffffff;
      --button-bg: linear-gradient(90deg, #0052D4, #4364F7, #6FB1FC); /* Vibrant blue gradient */
      --button-text: #ffffff;
      --button-refresh-bg: linear-gradient(135deg, #2ddc7a, #009e4b); /* New vibrant green gradient */
      --button-refresh-hover-bg: linear-gradient(135deg, #34f08a, #00b356); /* Lighter green on hover */
      --button-refresh-shadow: 0 5px 15px rgba(0, 158, 75, 0.4);
      --card-bg: #2a2a2a; /* Slightly lighter dark grey for cards */
      --card-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* More pronounced shadow for dark */
      --border-color: #333333; /* Darker border */
      --link-color: #6FB1FC; /* Brighter link color */
      --loading-color: #4364F7; /* Blue loading indicator */
      --error-color: #ff6b6b; /* Softer red for errors */
      --success-color: #4CAF50; /* Green for success */
      --font-family: 'Vazirmatn', sans-serif;
    }

    /* Simple CSS Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth; /* Smooth scrolling */
    }

    body {
      font-family: var(--font-family);
      background-color: var(--primary-bg);
      color: var(--text-color);
      line-height: 1.7; /* Slightly increased line height */
      display: flex;
      justify-content: center;
      padding-top: 80px; /* Increased Space for fixed header */
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #root {
      width: 100%;
      max-width: 750px; /* Slightly wider */
      padding: 25px;
      background-color: var(--secondary-bg);
      border-radius: 12px; /* More rounded corners */
      box-shadow: var(--card-shadow);
      margin: 20px;
      border: 1px solid var(--border-color);
      padding-bottom: 80px; /* Add padding to bottom to avoid overlap with refresh button */
    }

    header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 18px 20px; /* Slightly taller header */
      text-align: center;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4); /* Stronger shadow */
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    header h1 {
      margin: 0;
      font-size: 2em; /* Larger title */
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }

    #update {
      font-size: 0.9em;
      margin-top: 8px;
      color: var(--text-color-secondary);
    }

    .controls {
      display: grid;
      /* Remove refresh button from this grid calculation */
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .btn {
      padding: 14px 20px; /* Larger buttons */
      border: none;
      border-radius: 30px; /* Fully rounded buttons */
      font-size: 1.05em; /* Slightly larger font */
      font-weight: bold;
      cursor: pointer;
      background: var(--button-bg);
      color: var(--button-text);
      transition: all 0.3s ease;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      background-size: 200% auto; /* For gradient animation */
    }

    #output {
      margin-top: 25px;
      min-height: 150px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 20px;
      background-color: var(--card-bg); /* Card background for output */
      transition: background-color 0.3s ease;
      overflow: hidden; /* Needed for list item animation */
    }

    #output ul {
      list-style-type: none;
      padding: 0;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(15px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #output li {
      background: var(--secondary-bg); /* Darker background for list items */
      margin-bottom: 12px;
      padding: 15px 18px;
      border-radius: 8px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
      border-right: 5px solid var(--loading-color);
      transition: transform 0.25s ease, background-color 0.25s ease, border-color 0.25s ease;
      color: var(--text-color);
      font-size: 1.05em; /* Slightly larger text */
      cursor: pointer; /* Indicate clickable */
      opacity: 0; /* Start hidden for animation */
      animation: fadeInUp 0.5s ease forwards;
    }
    /* Stagger animation delay */
    #output li:nth-child(1) { animation-delay: 0.05s; }
    #output li:nth-child(2) { animation-delay: 0.1s; }
    #output li:nth-child(3) { animation-delay: 0.15s; }
    #output li:nth-child(4) { animation-delay: 0.2s; }
    #output li:nth-child(5) { animation-delay: 0.25s; }
    #output li:nth-child(6) { animation-delay: 0.3s; }
    #output li:nth-child(7) { animation-delay: 0.35s; }
    #output li:nth-child(8) { animation-delay: 0.4s; }
    #output li:nth-child(9) { animation-delay: 0.45s; }
    #output li:nth-child(10) { animation-delay: 0.5s; }
    /* Add more if needed */

    #output li:hover {
      transform: translateX(-6px) scale(1.01); /* Slight scale on hover */
      background-color: #333;
      border-right-color: var(--link-color);
    }

    #output li.error {
      color: var(--error-color);
      border-right-color: var(--error-color);
      font-weight: bold;
      cursor: default; /* Not clickable if error */
    }
    #output li.error span.error { /* Style the specific error span if needed */
      color: var(--error-color);
    }
    #output li.error:hover {
      transform: none; /* Disable hover effect for error items */
      background-color: var(--secondary-bg);
    }

    /* Styles for Conversion Modal (using SweetAlert now mostly) */
    /* Keep basic modal styles for potential future non-SweetAlert use */
    .modal { display: none; /* Hidden by default, SweetAlert handles visibility */ }
    .modal-content { background-color: var(--secondary-bg); color: var(--text-color); border: 1px solid var(--border-color); }
    .close-btn { color: #aaa; }
    .close-btn:hover, .close-btn:focus { color: var(--text-color); }
    .modal-content label { color: var(--text-color); }
    .modal-content input[type="number"], .modal-content select {
      background-color: var(--primary-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 6px;
    }
    .modal-content input::placeholder { color: var(--text-color-secondary); }
    .modal-content select option { background-color: var(--primary-bg); color: var(--text-color); }


    #conversionResult {
      margin-top: 20px;
      font-weight: bold;
      font-size: 1.1em;
      text-align: center;
      padding: 12px;
      background-color: var(--card-bg);
      border-radius: 6px;
      border: 1px solid var(--border-color);
      color: var(--success-color);
    }
    #conversionResult.error {
       color: var(--error-color);
     }

    /* Loading Spinner */
    .loader {
      border: 6px solid #444; /* Darker base */
      border-top: 6px solid var(--loading-color); /* Brighter top */
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 25px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* New styles for the fixed refresh button container */
    #refresh-container {
      position: fixed;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001; /* Ensure it's above other content */
    }

    #btnRefresh {
      width: 60px;
      height: 60px;
      border-radius: 50%; /* Make it circular */
      padding: 0; /* Remove padding */
      display: flex; /* Center the icon */
      align-items: center;
      justify-content: center;
      font-size: 1.8em; /* Adjust icon size */
      background: var(--button-refresh-bg);
      color: var(--button-text);
      box-shadow: var(--button-refresh-shadow);
      cursor: pointer;
      border: none;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smoother transition */
      outline: none;
    }

    #btnRefresh:hover {
      background: var(--button-refresh-hover-bg);
      transform: scale(1.1) translateY(-3px); /* Scale up and lift */
      box-shadow: 0 8px 20px rgba(0, 158, 75, 0.5); /* Stronger shadow on hover */
      filter: brightness(1.1);
    }

     #btnRefresh:active {
       transform: scale(1.05) translateY(-1px); /* Slightly smaller press effect */
       box-shadow: 0 4px 10px rgba(0, 158, 75, 0.4);
     }

    /* Responsive Design */
    @media (max-width: 700px) {
      body {
        padding-top: 70px;
      }
      #root {
        margin: 15px;
        padding: 20px;
        border-radius: 10px;
        padding-bottom: 90px; /* Ensure enough space at bottom */
      }
      header h1 {
        font-size: 1.7em;
      }
      .controls {
         grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
         gap: 12px;
         margin-bottom: 20px;
       }
      .btn {
        font-size: 1em;
        padding: 12px 15px;
      }
       #btnRefresh {
         width: 55px;
         height: 55px;
         font-size: 1.6em;
       }
       #refresh-container {
          bottom: 20px;
        }
       #output li {
         font-size: 1em;
         padding: 12px 15px;
       }
    }
    @media (max-width: 480px) {
       body { padding-top: 65px; }
       header h1 { font-size: 1.5em; }
       #update { font-size: 0.8em; }
       .controls {
         grid-template-columns: 1fr 1fr;
         grid-template-rows: auto auto; /* 2x2 grid */
         gap: 12px;
       }
       #btnRefresh {
         width: 50px;
         height: 50px;
         font-size: 1.5em;
       }
       #refresh-container {
         bottom: 15px;
       }
       #root {
         padding-bottom: 80px;
       }
     }

     /* SweetAlert Dark Theme Adjustments */
     body.swal2-shown > [aria-hidden="true"] {
       filter: blur(3px); /* Blur background when modal is open */
     }
     .swal2-popup {
       background: var(--secondary-bg) !important;
       color: var(--text-color) !important;
       border-radius: 10px !important;
       border: 1px solid var(--border-color);
       box-shadow: 0 5px 15px rgba(0,0,0,0.5) !important;
     }
     .swal2-title {
       color: var(--text-color) !important;
     }
     .swal2-html-container {
        color: var(--text-color-secondary) !important;
     }
     .swal2-input, .swal2-select {
       background: var(--primary-bg) !important;
       color: var(--text-color) !important;
       border: 1px solid var(--border-color) !important;
     }
      .swal2-input::placeholder { color: var(--text-color-secondary) !important; }
     .swal2-confirm {
       background: var(--button-bg) !important;
       background-image: var(--button-bg) !important; /* Ensure gradient applies */
       color: var(--button-text) !important;
       border-radius: 20px !important;
       padding: 10px 25px !important;
        transition: filter 0.2s ease !important;
        border: none !important;
     }
     .swal2-confirm:hover {
        filter: brightness(1.15) !important;
     }
     .swal2-cancel {
       background-color: #555 !important;
       color: var(--button-text) !important;
        border-radius: 20px !important;
        padding: 10px 25px !important;
        transition: background-color 0.3s ease !important;
        border: none !important;
     }
      .swal2-cancel:hover {
         background-color: #666 !important;
       }
      .swal2-loader {
         border-color: var(--loading-color) transparent var(--loading-color) transparent !important;
      }
      .swal2-success-ring {
        border-color: rgba(76, 175, 80, 0.7) !important; /* Slightly adjust success indicator */
      }

     /* Add Vazirmatn font */
     @font-face {
       font-family: 'Vazirmatn';
       src: url('https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/fonts/webfonts/Vazirmatn-Regular.woff2') format('woff2');
       font-weight: normal;
       font-style: normal;
       font-display: swap;
     }
     @font-face {
       font-family: 'Vazirmatn';
       src: url('https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/fonts/webfonts/Vazirmatn-Bold.woff2') format('woff2');
       font-weight: bold;
       font-style: normal;
       font-display: swap;
    }
  </style>
</head>
<body>
  <header>
    <h1>ğŸ’µ Chand ğŸ’µ</h1>
    <p id="update">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ§Ø±ÛŒØ®...</p>
  </header>

  <div id="root">
    <div class="controls">
      <button class="btn" id="btnCurrency">Ø§Ø±Ø²Ù‡Ø§ ğŸ’µ</button>
      <button class="btn" id="btnGold">Ù‚ÛŒÙ…Øª Ø·Ù„Ø§ ğŸª™</button>
      <button class="btn" id="btnCoin">Ù‚ÛŒÙ…Øª Ø³Ú©Ù‡ ğŸ’°</button>
      <button class="btn" id="btnConvert">ØªØ¨Ø¯ÛŒÙ„ Ø§Ø±Ø² ğŸ’±</button>
    </div>
    <div id="output">
      <p style="text-align: center; color: var(--text-color-secondary);">Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ØŒ ÛŒÚ©ÛŒ Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù„Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.</p>
    </div>
  </div>

  <!-- Refresh Button Container Added at the end -->
  <div id="refresh-container">
    <button class="btn" id="btnRefresh" title="Ø±ÙØ±Ø´ Ùˆ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ú©Ø´">ğŸ”„</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script>
    const chandeUrl = 'https://cors-anywhere.herokuapp.com/https://chande.net';
    const tgjuBaseUrl = 'https://cors-anywhere.herokuapp.com/https://www.tgju.org/profile/';
    const CACHE_DURATION_MINUTES = 5; // Cache data for 5 minutes
    const CACHE_PREFIX = 'chand_cache_';

    const currencies = [
      { code: 'usd', title: 'Ø¯Ù„Ø§Ø± Ø¢Ù…Ø±ÛŒÚ©Ø§', unit: 'ØªÙˆÙ…Ø§Ù†', chandeCode: 'USD', tgjuProfile: 'price_dollar_rl' },
      { code: 'eur', title: 'ÛŒÙˆØ±Ùˆ', unit: 'ØªÙˆÙ…Ø§Ù†', chandeCode: 'EUR' , tgjuProfile: 'price_eur'},
      { code: 'gbp', title: 'Ù¾ÙˆÙ†Ø¯ Ø§Ù†Ú¯Ù„ÛŒØ³', unit: 'ØªÙˆÙ…Ø§Ù†', chandeCode: 'GBP', tgjuProfile: 'price_gbp' },
      { code: 'aed', title: 'Ø¯Ø±Ù‡Ù… Ø§Ù…Ø§Ø±Ø§Øª', unit: 'ØªÙˆÙ…Ø§Ù†', chandeCode: 'AED', tgjuProfile: 'price_aed' }
    ];

    const additionalAssets = [
      { title: 'Ø·Ù„Ø§ 18 Ø¹ÛŒØ§Ø±', profile: 'geram18', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'gold', needsTomanConversion: true },
      { title: 'Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ Ø·Ù„Ø§', profile: 'ons', unit: 'Ø¯Ù„Ø§Ø±', category: 'gold', needsTomanConversion: false },
      { title: 'Ù…Ø«Ù‚Ø§Ù„ Ø·Ù„Ø§', profile: 'mesghal', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'gold', needsTomanConversion: true },
      { title: 'Ø·Ù„Ø§ÛŒ Û²Û´ Ø¹ÛŒØ§Ø±', profile: 'geram24', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'gold', needsTomanConversion: true },
      { title: 'Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ', profile: 'sekee', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'coin', needsTomanConversion: true },
      { title: 'Ù†ÛŒÙ… Ø³Ú©Ù‡', profile: 'nim', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'coin', needsTomanConversion: true },
      { title: 'Ø±Ø¨Ø¹ Ø³Ú©Ù‡', profile: 'rob', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'coin', needsTomanConversion: true },
      { title: 'Ø³Ú©Ù‡ Ú¯Ø±Ù…ÛŒ', profile: 'gerami', unit: 'ØªÙˆÙ…Ø§Ù†', category: 'coin', needsTomanConversion: true }
    ];

    const outputDiv = document.getElementById('output');
    const updateEl = document.getElementById('update');
    let conversionRatesPromise = null;
    let lastFetchedCategory = null; // To store the last category fetched ('currency', 'gold', 'coin')

    // --- Caching Functions ---
    function saveToCache(key, data) {
        try {
            const cacheEntry = {
                timestamp: Date.now(),
                data: data
            };
            localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(cacheEntry));
        } catch (e) {
            console.error("Error saving to localStorage", e);
        }
    }

    function loadFromCache(key, maxAgeMinutes = CACHE_DURATION_MINUTES) {
        try {
            const item = localStorage.getItem(CACHE_PREFIX + key);
            if (!item) return null;

            const cacheEntry = JSON.parse(item);
            const ageMillis = Date.now() - cacheEntry.timestamp;
            if (ageMillis > maxAgeMinutes * 60 * 1000) {
                localStorage.removeItem(CACHE_PREFIX + key); // Remove expired entry
                return null;
            }
            console.log(`Using cached data for ${key}`);
            return cacheEntry.data;
        } catch (e) {
            console.error("Error loading from localStorage", e);
            return null;
        }
    }

     function clearCache(...keys) {
         console.log("Clearing cache for keys:", keys);
         keys.forEach(key => {
             try {
                 localStorage.removeItem(CACHE_PREFIX + key);
             } catch (e) {
                 console.error(`Error removing ${key} from localStorage`, e);
             }
         });
     }

    // --- Helper Functions ---

    function convertToToman(price) {
      return typeof price === 'number' && !isNaN(price) ? price / 10 : price;
    }

    function formatPrice(price, unit = 'ØªÙˆÙ…Ø§Ù†') {
      if (price === 'error' || price === null || typeof price === 'undefined' || isNaN(price)) {
        return `<span class="error">Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª</span>`;
      }
      const number = Number(price);
      if (isNaN(number)) {
        return `<span class="error">Ù†Ø§Ù…Ø¹ØªØ¨Ø±</span>`;
      }
      return `${number.toLocaleString('fa-IR')} ${unit}`;
    }

    // Extracts plain text from the list item's HTML for copying
    function getPlainText(htmlString) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlString;
      return tempDiv.textContent || tempDiv.innerText || "";
    }

    function showLoading() {
      outputDiv.innerHTML = '<div class="loader"></div><p style="text-align:center; color: var(--text-color-secondary);">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...</p>';
    }

    function showOutput(items) {
      outputDiv.innerHTML = ''; // Clear previous content
      if (!items || items.length === 0) {
        outputDiv.innerHTML = '<p style="text-align:center; color: var(--text-color-secondary);">Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.</p>';
        return;
      }
      const ul = document.createElement('ul');
      items.forEach((item, index) => { // Add index for animation delay
        const li = document.createElement('li');
        li.innerHTML = item.label;
        li.style.animationDelay = `${index * 0.05}s`; // Apply staggered delay

        if (item.label.includes('error') || item.label.includes('Ø®Ø·Ø§') || item.label.includes('Ù†Ø§Ù…Ø¹ØªØ¨Ø±')) {
          li.classList.add('error');
        } else {
          // Add click listener only for valid items
          li.addEventListener('click', () => handleItemClick(li));
        }
        ul.appendChild(li);
      });
      outputDiv.appendChild(ul);
    }

    // Function to handle clicking on a list item for copying
    async function handleItemClick(listItem) {
      const textToCopy = getPlainText(listItem.innerHTML);
      if (!textToCopy || !navigator.clipboard) {
        Swal.fire('Ø®Ø·Ø§', 'Ø§Ù…Ú©Ø§Ù† Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.', 'error');
        return;
      }

      try {
        const result = await Swal.fire({
          title: 'Ú©Ù¾ÛŒ Ø¯Ø± Ú©Ù„ÛŒÙ¾â€ŒØ¨ÙˆØ±Ø¯',
          html: `Ø¢ÛŒØ§ Ù…Ø§ÛŒÙ„ Ø¨Ù‡ Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† Ù…ØªÙ† Ø²ÛŒØ± Ù‡Ø³ØªÛŒØ¯ØŸ<br><strong style="color: var(--link-color); display: block; margin-top: 10px; direction: ltr; text-align: center;">${textToCopy}</strong>`,
          icon: 'question',
          showCancelButton: true,
          confirmButtonText: 'Ø¨Ù„Ù‡ØŒ Ú©Ù¾ÛŒ Ú©Ù†',
          cancelButtonText: 'Ø§Ù†ØµØ±Ø§Ù',
          reverseButtons: true
        });

        if (result.isConfirmed) {
          await navigator.clipboard.writeText(textToCopy);
          Swal.fire({
            title: 'Ú©Ù¾ÛŒ Ø´Ø¯!',
            text: 'Ù…ØªÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¯Ø± Ú©Ù„ÛŒÙ¾â€ŒØ¨ÙˆØ±Ø¯ Ú©Ù¾ÛŒ Ø´Ø¯.',
            icon: 'success',
            timer: 1500, // Auto-close timer
            showConfirmButton: false
          });
        }
      } catch (err) {
        console.error('Failed to copy: ', err);
        Swal.fire('Ø®Ø·Ø§', 'Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† Ù…ØªÙ† Ø¨Ø§ Ù…Ø´Ú©Ù„ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.', 'error');
      }
    }

    // --- Fetching Functions --- (Modified for Caching)

    async function fetchData(url, options = {}, timeout = 15000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      let corsProxyActivated = sessionStorage.getItem('corsProxyActivated');

      const promptActivateProxy = async () => {
        const result = await Swal.fire({
          title: 'ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ',
          html: `Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ØŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ú©Ù…Ú©ÛŒ (CORS Proxy) Ø§Ø³Øª.<br>Ù„Ø·ÙØ§ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ Ùˆ Ø³Ù¾Ø³ Ø¯Ú©Ù…Ù‡ "Request temporary access to the demo server" Ø±Ø§ Ø¯Ø± ØµÙØ­Ù‡ Ø¨Ø§Ø² Ø´Ø¯Ù‡ Ø¨Ø²Ù†ÛŒØ¯ Ùˆ Ø¨Ù‡ Ø§ÛŒÙ† ØµÙØ­Ù‡ Ø¨Ø±Ú¯Ø±Ø¯ÛŒØ¯.`,
          icon: 'info',
          confirmButtonText: 'ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ',
          showCancelButton: true,
          cancelButtonText: 'Ø§Ù†ØµØ±Ø§Ù',
          allowOutsideClick: false
        });
        if (result.isConfirmed) {
          window.open('https://cors-anywhere.herokuapp.com/corsdemo', '_blank');
          sessionStorage.setItem('corsProxyActivated', 'true');
          Swal.fire('Ø¯Ø³ØªØ±Ø³ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯!', 'Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¯Ú©Ù…Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.', 'success');
          return true;
        }
        return false;
      };

      try {
        const fetchOptions = { ...options, signal: controller.signal, headers: { 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'Mozilla/5.0...' } };
        const response = await fetch(url, fetchOptions);
        clearTimeout(id);
        if (!response.ok) {
          console.error(`Fetch error for ${url}: ${response.status} ${response.statusText}`);
          if (response.status === 403 && url.includes('cors-anywhere')) {
            console.warn(`CORS Proxy issue detected for ${url}.`);
            if (!corsProxyActivated) {
              await promptActivateProxy();
              return { error: true, status: 'cors_proxy_activation_needed', data: null };
            } else {
              console.error('CORS Proxy access likely expired or failed.');
              return { error: true, status: response.status, data: null, corsExpired: true };
            }
          }
          return { error: true, status: response.status, data: null };
        }
        const textData = await response.text();
        return { error: false, data: textData };
      } catch (error) {
        clearTimeout(id);
        if (error.name === 'AbortError') {
          console.error(`Fetch timed out for ${url}`);
          return { error: true, data: null, status: 'timeout' };
        }
        console.error(`Network or fetch error for ${url}:`, error);
        return { error: true, data: null, status: 'network_error' };
      }
    }

    async function fetchPriceFromChande(currencyCode, forceRefresh = false) {
      const cacheKey = `chande_${currencyCode}`;
      if (!forceRefresh) {
        const cachedData = loadFromCache(cacheKey);
        if (cachedData !== null) return cachedData; // Use !== null to allow caching 'error'
      }

      const result = await fetchData(chandeUrl);
      if (result.error) {
        saveToCache(cacheKey, 'error'); // Cache the error state
        return result.status === 'cors_proxy_activation_needed' ? 'cors_activation' : 'error';
      }
      if (!result.data) {
        saveToCache(cacheKey, 'error');
        return 'error';
      }

      try {
        const html = result.data;
        const regex = new RegExp(`<th[^>]*>\s*${currencyCode}\s*<\/th>.*?<td[^>]*>\s*([\d,.]+)\s*<\/td>`, 'is');
        const match = html.match(regex);
        const price = match && match[1] ? parseInt(match[1].replace(/,/g, '')) : 'error';
        saveToCache(cacheKey, price);
        return price;
      } catch (e) {
        console.error(`Error parsing Chande.net HTML for ${currencyCode}:`, e);
        saveToCache(cacheKey, 'error');
        return 'error';
      }
    }

    async function fetchPriceFromTGJU(profile, forceRefresh = false) {
      const cacheKey = `tgju_${profile}`;
      if (!forceRefresh) {
        const cachedData = loadFromCache(cacheKey);
        if (cachedData !== null) return cachedData;
      }

      const url = `${tgjuBaseUrl}${profile}`;
      const result = await fetchData(url);
      if (result.error) {
        saveToCache(cacheKey, 'error');
        if (result.status === 'cors_proxy_activation_needed') return 'cors_activation';
        if (result.corsExpired) console.warn(`Skipping TGJU fetch for ${profile} due to potential expired CORS proxy.`);
        return 'error';
      }
      if (!result.data) {
        saveToCache(cacheKey, 'error');
        return 'error';
      }

      try {
        const html = result.data;
        const regex = /<td\s+class="text-left"[^>]*>\s*([\d,.]+)\s*<\/td>/i;
        const match = html.match(regex);
        const price = match && match[1] ? parseFloat(match[1].replace(/,/g, '')) : 'error';
        saveToCache(cacheKey, price);
        return price;
      } catch (e) {
        console.error(`Error parsing TGJU HTML for ${profile}:`, e);
        saveToCache(cacheKey, 'error');
        return 'error';
      }
    }

    async function fetchCurrencyPrices(forceRefresh = false) {
      const cacheKey = 'currency_prices';
      if (!forceRefresh) {
        const cachedData = loadFromCache(cacheKey);
        if (cachedData) return cachedData;
      }

      const results = [];
      let corsPrompted = false;
      for (const cur of currencies) {
        const priceChande = await fetchPriceFromChande(cur.chandeCode, forceRefresh);
        if (priceChande === 'cors_activation') { corsPrompted = true; break; }
        let priceTGJU = 'error';
        if (cur.tgjuProfile) {
          priceTGJU = await fetchPriceFromTGJU(cur.tgjuProfile, forceRefresh);
          if (priceTGJU === 'cors_activation') { corsPrompted = true; break; }
        }
        results.push({ label: `${cur.title} (Ù†Ø±Ø® 1 - Chande): ${formatPrice(priceChande, cur.unit)}` });
        if (cur.tgjuProfile) {
          results.push({ label: `${cur.title} (Ù†Ø±Ø® 2 - TGJU): ${formatPrice( (priceTGJU !== 'error' ? convertToToman(priceTGJU) : 'error'), cur.unit)}` });
        }
      }
      if (corsPrompted) return null;
      saveToCache(cacheKey, results);
      return results;
    }

    async function fetchCurrencyRatesForConversion(forceRefresh = false) {
      const cacheKey = 'conversion_rates';
      if (!forceRefresh) {
        const cachedData = loadFromCache(cacheKey);
        if (cachedData && cachedData.error === null) {
          console.log("Using cached conversion rates.");
          return cachedData;
        }
      }

      console.log("Fetching conversion rates...");
      const rates = {};
      let corsPrompted = false;
      let fetchSucceeded = false;
      for (const cur of currencies) {
        const price = await fetchPriceFromChande(cur.chandeCode, forceRefresh);
        if (price === 'cors_activation') {
          corsPrompted = true;
          break;
        }
        if (price !== 'error') {
          rates[cur.code] = price;
          fetchSucceeded = true;
        } else {
          rates[cur.code] = null;
        }
      }
      console.log("Conversion rates fetched:", rates);

      let result;
      if (corsPrompted) {
        result = { rates: null, error: 'cors_activation' };
      } else if (!fetchSucceeded) {
        result = { rates: null, error: 'fetch_failed' };
      } else {
        result = { rates: rates, error: null };
      }
      saveToCache(cacheKey, result);
      return result;
    }

    async function fetchAssetPrices(category, forceRefresh = false) {
      const cacheKey = `${category}_prices`;
      if (!forceRefresh) {
        const cachedData = loadFromCache(cacheKey);
        if (cachedData) return cachedData;
      }

      const assets = additionalAssets.filter(a => a.category === category);
      const results = [];
      let corsPrompted = false;
      for (const asset of assets) {
        const price = await fetchPriceFromTGJU(asset.profile, forceRefresh);
        if (price === 'cors_activation') { corsPrompted = true; break; }
        let displayPrice = price;
        if (asset.needsTomanConversion && price !== 'error') {
          displayPrice = convertToToman(price);
        }
        results.push({ label: `${asset.title}: ${formatPrice(displayPrice, asset.unit)}` });
      }
      if (corsPrompted) return null;
      saveToCache(cacheKey, results);
      return results;
    }

    // --- Trigger Fetch Function ---
    async function triggerFetch(category, forceRefresh = false) {
      lastFetchedCategory = category; // Store the category being fetched
      showLoading();
      let data;
      switch (category) {
        case 'currency':
          data = await fetchCurrencyPrices(forceRefresh);
          break;
        case 'gold':
          data = await fetchAssetPrices('gold', forceRefresh);
          break;
        case 'coin':
          data = await fetchAssetPrices('coin', forceRefresh);
          break;
        default:
          console.error("Invalid category:", category);
          outputDiv.innerHTML = '<p style="text-align:center; color: var(--error-color);">Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ: Ø¯Ø³ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±.</p>';
          return;
      }

      if (data === null) {
        outputDiv.innerHTML = '<p style="text-align:center; color: var(--text-color-secondary);">Ù„Ø·ÙØ§ Ù¾Ø³ Ø§Ø² ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.</p>';
        return;
      }
      showOutput(data);
    }

    // --- Event Listeners ---

    document.getElementById('btnCurrency').addEventListener('click', () => triggerFetch('currency'));
    document.getElementById('btnGold').addEventListener('click', () => triggerFetch('gold'));
    document.getElementById('btnCoin').addEventListener('click', () => triggerFetch('coin'));

    document.getElementById('btnRefresh').addEventListener('click', () => {
      console.log("Refresh button clicked.");
      // Clear all relevant caches
      clearCache('currency_prices', 'gold_prices', 'coin_prices', 'conversion_rates');
      // Also clear individual price caches that might exist
      currencies.forEach(c => clearCache(`chande_${c.chandeCode}`, `tgju_${c.tgjuProfile}`));
      additionalAssets.forEach(a => clearCache(`tgju_${a.profile}`));

      // Force refresh conversion rates in the background
      conversionRatesPromise = fetchCurrencyRatesForConversion(true);
      conversionRatesPromise.catch(err => { console.error("Error during refresh pre-fetch:", err); });

      // If a category was previously viewed, refresh it
      if (lastFetchedCategory) {
        console.log("Refreshing last category:", lastFetchedCategory);
        triggerFetch(lastFetchedCategory, true); // Pass true to force refresh
      } else {
        // Otherwise, just clear the output
        outputDiv.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary);">Ú©Ø´ Ù¾Ø§Ú© Ø´Ø¯. ÛŒÚ© Ø¯Ø³ØªÙ‡ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.</p>';
      }

      // Give visual feedback
      Swal.fire({
        icon: 'info',
        title: 'Ø±ÙØ±Ø´ Ø´Ø¯',
        text: 'Ø­Ø§ÙØ¸Ù‡ Ù¾Ù†Ù‡Ø§Ù† Ù¾Ø§Ú© Ø´Ø¯ Ùˆ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ø±Ø³Ø§Ù„ Ú¯Ø±Ø¯ÛŒØ¯.',
        toast: true, // Make it a small toast notification
        position: 'top-end', // Position at top-right
        showConfirmButton: false,
        timer: 2500, // Auto-close after 2.5 seconds
        timerProgressBar: true
      });
    });

    document.getElementById('btnConvert').addEventListener('click', async () => {
      if (!conversionRatesPromise) {
        console.error("Conversion rates promise not initialized!");
        Swal.fire('Ø®Ø·Ø§', 'Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù†Ø±Ø®â€ŒÙ‡Ø§ØŒ Ù„Ø·ÙØ§ Ú†Ù†Ø¯ Ù„Ø­Ø¸Ù‡ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.', 'warning');
        return;
      }

      const currencyOptions = currencies.reduce((acc, cur) => {
        acc[cur.code] = `${cur.title} (${cur.code.toUpperCase()})`;
        return acc;
      }, {});

      const { value: formValues } = await Swal.fire({
        title: 'ØªØ¨Ø¯ÛŒÙ„ Ø§Ø±Ø² ğŸ’±',
        html:
          `<label for="swal-input-amount" style="display: block; text-align: right; margin-bottom: 5px;">Ù…Ù‚Ø¯Ø§Ø±:</label>` +
          '<input id="swal-input-amount" class="swal2-input" placeholder="Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø¯Ø¯ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯" type="number" min="0" style="width: 95%; margin-bottom: 10px;">' +
          `<label for="swal-select-source" style="display: block; text-align: right; margin-bottom: 5px;">Ø§Ø² Ø§Ø±Ø²:</label>` +
          '<select id="swal-select-source" class="swal2-select" style="width: 95%; margin-bottom: 10px;"></select>' +
          `<label for="swal-select-target" style="display: block; text-align: right; margin-bottom: 5px;">Ø¨Ù‡ Ø§Ø±Ø²:</label>` +
          '<select id="swal-select-target" class="swal2-select" style="width: 95%;"></select>',
        focusConfirm: false,
        confirmButtonText: 'Ù…Ø­Ø§Ø³Ø¨Ù‡',
        showCancelButton: true,
        cancelButtonText: 'Ø§Ù†ØµØ±Ø§Ù',
        showLoaderOnConfirm: true,
        didOpen: () => {
          const sourceSelect = document.getElementById('swal-select-source');
          const targetSelect = document.getElementById('swal-select-target');
          for (const code in currencyOptions) {
            sourceSelect.add(new Option(currencyOptions[code], code));
            targetSelect.add(new Option(currencyOptions[code], code));
          }
          sourceSelect.value = 'usd';
          targetSelect.value = 'eur';
          document.getElementById('swal-input-amount').onkeyup = (event) => event.key === 'Enter' && Swal.clickConfirm();
        },
        preConfirm: async () => {
          const amount = document.getElementById('swal-input-amount').value;
          const source = document.getElementById('swal-select-source').value;
          const target = document.getElementById('swal-select-target').value;
          const numericAmount = parseFloat(amount);

          if (isNaN(numericAmount) || numericAmount <= 0 || !source || !target) {
            Swal.showValidationMessage('Ù„Ø·ÙØ§Ù‹ Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø¯Ø¯ÛŒ Ù…Ø¹ØªØ¨Ø± Ùˆ Ù‡Ø± Ø¯Ùˆ Ø§Ø±Ø² Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
            return false;
          }

          try {
            // Await the rates promise (might be cached or fetched on load)
            const ratesResult = await conversionRatesPromise;
            if (ratesResult.error === 'cors_activation') {
              Swal.showValidationMessage('Ù„Ø·ÙØ§ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ú©Ù…Ú©ÛŒ Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù‡ Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.');
              return false;
            }
            if (ratesResult.error || !ratesResult.rates) {
              Swal.showValidationMessage('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø®â€ŒÙ‡Ø§. Ù„Ø·ÙØ§ Ø¨Ø¹Ø¯Ø§ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
              return false;
            }
            const rates = ratesResult.rates;
            if (rates[source] === null || rates[target] === null) {
              Swal.showValidationMessage('Ù†Ø±Ø® Ø§Ø±Ø² Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯.');
              return false;
            }
            if (rates[target] === 0) {
              Swal.showValidationMessage('Ù†Ø±Ø® Ø§Ø±Ø² Ù…Ù‚ØµØ¯ ØµÙØ± Ø§Ø³Øª.');
              return false;
            }
            const result = (numericAmount * rates[source]) / rates[target];
            return { amount: numericAmount, source, target, result };
          } catch (error) {
            console.error("Error during preConfirm rate fetching:", error);
            Swal.showValidationMessage('Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø®â€ŒÙ‡Ø§.');
            return false;
          }
        }
      });

      if (formValues) {
        const { amount, source, target, result } = formValues;
        const targetCurrencyInfo = currencies.find(c => c.code === target);
        const sourceCurrencyInfo = currencies.find(c => c.code === source);
        const formattedAmount = amount.toLocaleString('fa-IR');
        const formattedResult = result.toLocaleString('fa-IR', { maximumFractionDigits: 2 });
        Swal.fire({
          icon: 'success',
          title: 'Ù†ØªÛŒØ¬Ù‡ ØªØ¨Ø¯ÛŒÙ„',
          html: `
            <div style="text-align: center; font-size: 1.1em; margin-top: 15px;">
              <strong>${formattedAmount}</strong> ${sourceCurrencyInfo?.title || source.toUpperCase()}
              <br>Ø¨Ø±Ø§Ø¨Ø± Ø§Ø³Øª Ø¨Ø§<br>
              <strong>${formattedResult}</strong> ${targetCurrencyInfo?.title || target.toUpperCase()}
            </div>
          `,
          confirmButtonText: 'ÙÙ‡Ù…ÛŒØ¯Ù…'
        });
      }
    });

    // --- Date/Time Update ---
    function updateDateTime() {
      try {
        const now = new Date();
        const persianDate = now.toLocaleDateString('fa-IR-u-nu-latn', {
          timeZone: 'Asia/Tehran', year: 'numeric', month: 'long', day: 'numeric' // Use long month name
        });

        const time = now.toLocaleTimeString('fa-IR-u-nu-latn', {
          timeZone: 'Asia/Tehran', hour: '2-digit', minute: '2-digit', hour12: false
        });

        updateEl.textContent = `Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${persianDate} - ${time}`;
      } catch (e) {
        console.error("Error updating date/time:", e);
        updateEl.textContent = "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø²Ù…Ø§Ù†";
      }
    }

    // --- Initialization ---
    function initializeApp() {
      updateDateTime();
      setInterval(updateDateTime, 30000);

      // Start pre-fetching conversion rates (will use cache if available)
      conversionRatesPromise = fetchCurrencyRatesForConversion();
      conversionRatesPromise.catch(err => {
        console.error("Error during initial conversion rate pre-fetch:", err);
      });
      console.log("Chand Web App Initialized (Dark Mode, Optimized with Cache).");
    }

    // Run initialization when the DOM is ready
    document.addEventListener('DOMContentLoaded', initializeApp);

  </script>
</body>
</html>
