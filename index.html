<!-- index.html -->
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>اپ Chand روی وب - مدرن</title>
  <!-- SweetAlert2 CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root {
      /* Dark Theme Palette */
      --primary-bg: #121212; /* Very dark grey (almost black) */
      --secondary-bg: #1e1e1e; /* Dark grey */
      --text-color: #e0e0e0; /* Light grey for text */
      --text-color-secondary: #b3b3b3; /* Slightly dimmer text */
      --header-bg: linear-gradient(90deg, #0f2027, #203a43, #2c5364); /* Dark blue/grey gradient */
      --header-text: #ffffff;
      --button-bg: linear-gradient(90deg, #0052D4, #4364F7, #6FB1FC); /* Vibrant blue gradient */
      --button-text: #ffffff;
      --button-refresh-bg: linear-gradient(135deg, #2ddc7a, #009e4b); /* New vibrant green gradient */
      --button-refresh-hover-bg: linear-gradient(135deg, #34f08a, #00b356); /* Lighter green on hover */
      --button-refresh-shadow: 0 5px 15px rgba(0, 158, 75, 0.4);
      --card-bg: #2a2a2a; /* Slightly lighter dark grey for cards */
      --card-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); /* More pronounced shadow for dark */
      --border-color: #333333; /* Darker border */
      --link-color: #6FB1FC; /* Brighter link color */
      --loading-color: #4364F7; /* Blue loading indicator */
      --error-color: #ff6b6b; /* Softer red for errors */
      --success-color: #4CAF50; /* Green for success */
      --font-family: 'Vazirmatn', sans-serif;
    }

    /* Simple CSS Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth; /* Smooth scrolling */
    }

    body {
      font-family: var(--font-family);
      background-color: var(--primary-bg);
      color: var(--text-color);
      line-height: 1.7; /* Slightly increased line height */
      display: flex;
      justify-content: center;
      padding-top: 90px; /* Slightly increased padding for larger default header */
      padding-bottom: 100px; /* Consistent bottom padding for refresh button */
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #root {
      width: 95%; /* Use percentage for better fluidity */
      max-width: 900px; /* Increased max-width for web */
      padding: 30px; /* Increased padding */
      background-color: var(--secondary-bg);
      border-radius: 15px; /* Slightly more rounded */
      box-shadow: var(--card-shadow);
      margin: 20px auto; /* Center horizontally */
      border: 1px solid var(--border-color);
      /* Removed fixed padding-bottom, handle spacing differently */
      transition: transform 0.3s ease, box-shadow 0.3s ease; /* Added transition */
    }

    @keyframes slideDown {
      from { transform: translateY(-100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 20px 25px; /* Increased header padding */
      text-align: center;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4); /* Stronger shadow */
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      animation: slideDown 0.6s ease-out forwards; /* Header slide down animation */
    }

    header h1 {
      margin: 0;
      font-size: 2.1em; /* Slightly larger base size */
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
    header h1 i {
      margin: 0 10px; /* Space around header icon */
      font-size: 0.9em;
      opacity: 0.8;
    }

    #update {
      font-size: 0.95em; /* Slightly larger */
      margin-top: 8px;
      color: var(--text-color-secondary);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* Increased min button width */
      gap: 18px; /* Increased gap */
      margin-bottom: 30px; /* Increased margin */
    }

    .btn {
      padding: 15px 22px; /* Slightly larger padding */
      border: none;
      border-radius: 30px;
      font-size: 1.1em; /* Slightly larger base font */
      font-weight: bold;
      cursor: pointer;
      background: var(--button-bg);
      color: var(--button-text);
      transition: all 0.3s ease;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      background-size: 200% auto; /* For gradient animation */
      display: flex; /* Use flex for icon alignment */
      align-items: center;
      justify-content: center;
      gap: 10px; /* Space between icon and text */
    }
     .btn i {
         font-size: 1.1em; /* Adjust icon size within button */
         line-height: 1; /* Ensure proper vertical alignment */
     }

    .btn:hover {
      background-position: right center;
      filter: brightness(1.15);
      transform: translateY(-4px) scale(1.02); /* Slightly more lift and scale */
      box-shadow: 0 7px 14px rgba(0, 0, 0, 0.25);
    }

    .btn:active {
      transform: translateY(-1px) scale(0.98); /* Slightly shrink on active */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    #output {
      margin-top: 30px; /* Increased margin */
      min-height: 180px; /* Increased min height */
      border: 1px solid var(--border-color);
      border-radius: 12px; /* Match root rounding */
      padding: 25px; /* Increased padding */
      background-color: var(--card-bg); /* Card background for output */
      transition: background-color 0.3s ease;
      overflow: hidden; /* Needed for list item animation */
    }

    #output ul {
      list-style-type: none;
      padding: 0;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(15px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #output li {
      background: var(--secondary-bg); /* Darker background for list items */
      margin-bottom: 14px; /* Increased spacing */
      padding: 16px 20px; /* Adjusted padding */
      border-radius: 10px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
      border-right: 5px solid var(--loading-color);
      transition: transform 0.25s ease, background-color 0.25s ease, border-color 0.25s ease;
      color: var(--text-color);
      font-size: 1.1em; /* Slightly larger base font */
      cursor: pointer; /* Indicate clickable */
      opacity: 0; /* Start hidden for animation */
      animation: fadeInUp 0.5s ease forwards;
    }
    /* Stagger animation delay */
    #output li:nth-child(1) { animation-delay: 0.05s; }
    #output li:nth-child(2) { animation-delay: 0.1s; }
    #output li:nth-child(3) { animation-delay: 0.15s; }
    #output li:nth-child(4) { animation-delay: 0.2s; }
    #output li:nth-child(5) { animation-delay: 0.25s; }
    #output li:nth-child(6) { animation-delay: 0.3s; }
    #output li:nth-child(7) { animation-delay: 0.35s; }
    #output li:nth-child(8) { animation-delay: 0.4s; }
    #output li:nth-child(9) { animation-delay: 0.45s; }
    #output li:nth-child(10) { animation-delay: 0.5s; }
    /* Add more if needed */

    #output li:hover {
      transform: translateX(-6px) scale(1.01); /* Slight scale on hover */
      background-color: #333;
      border-right-color: var(--link-color);
    }

    #output li.error {
      color: var(--error-color);
      border-right-color: var(--error-color);
      font-weight: bold;
      cursor: default; /* Not clickable if error */
    }
    #output li.error span.error { /* Style the specific error span if needed */
      color: var(--error-color);
    }
    #output li.error:hover {
      transform: none; /* Disable hover effect for error items */
      background-color: var(--secondary-bg);
    }

    /* Styles for Conversion Modal (using SweetAlert now mostly) */
    /* Keep basic modal styles for potential future non-SweetAlert use */
    .modal { display: none; /* Hidden by default, SweetAlert handles visibility */ }
    .modal-content { background-color: var(--secondary-bg); color: var(--text-color); border: 1px solid var(--border-color); }
    .close-btn { color: #aaa; }
    .close-btn:hover, .close-btn:focus { color: var(--text-color); }
    .modal-content label { color: var(--text-color); }
    .modal-content input[type="number"], .modal-content select {
      background-color: var(--primary-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 6px;
    }
    .modal-content input::placeholder { color: var(--text-color-secondary); }
    .modal-content select option { background-color: var(--primary-bg); color: var(--text-color); }


    #conversionResult {
      margin-top: 20px;
      font-weight: bold;
      font-size: 1.1em;
      text-align: center;
      padding: 12px;
      background-color: var(--card-bg);
      border-radius: 6px;
      border: 1px solid var(--border-color);
      color: var(--success-color);
    }
    #conversionResult.error {
       color: var(--error-color);
     }

    /* Loading Spinner */
    .loader {
      border: 6px solid #444; /* Darker base */
      border-top: 6px solid var(--loading-color); /* Brighter top */
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 25px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* New styles for the fixed refresh button container */
    #refresh-container {
      position: fixed;
      bottom: 30px; /* Increased distance from bottom */
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
    }

    @keyframes spinRefresh {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    #btnRefresh {
      width: 65px; /* Slightly larger */
      height: 65px;
      border-radius: 50%; /* Make it circular */
      padding: 0; /* Remove padding */
      display: flex; /* Center the icon */
      align-items: center;
      justify-content: center;
      font-size: 1.6em; /* Adjusted for Font Awesome icon */
      background: var(--button-refresh-bg);
      color: var(--button-text);
      box-shadow: var(--button-refresh-shadow);
      cursor: pointer;
      border: none;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smoother transition */
      outline: none;
    }
    /* Class added during refresh */
    #btnRefresh.loading i {
      animation: spinRefresh 1s linear infinite;
    }
    #btnRefresh.loading {
      cursor: not-allowed;
      filter: brightness(0.8);
    }

    #btnRefresh:hover {
      background: var(--button-refresh-hover-bg);
      transform: scale(1.1) translateY(-3px); /* Scale up and lift */
      box-shadow: 0 8px 20px rgba(0, 158, 75, 0.5); /* Stronger shadow on hover */
      filter: brightness(1.1);
    }
    /* Prevent hover effect when loading */
    #btnRefresh.loading:hover {
       background: var(--button-refresh-bg); /* Revert background */
       transform: scale(1) translateY(0); /* Revert transform */
       box-shadow: var(--button-refresh-shadow); /* Revert shadow */
       filter: brightness(0.8);
     }

     #btnRefresh:active {
       transform: scale(1.05) translateY(-1px); /* Slightly smaller press effect */
       box-shadow: 0 4px 10px rgba(0, 158, 75, 0.4);
     }

    /* Responsive Design */
    @media (min-width: 1200px) {
      #root {
        max-width: 1100px; /* Even wider on very large screens */
      }
      header h1 {
        font-size: 2.3em;
      }
      .btn {
        font-size: 1.15em;
      }
      #output li {
        font-size: 1.15em;
      }
    }
    @media (max-width: 900px) {
       body { padding-top: 80px; padding-bottom: 90px;}
       #root {
           width: 90%; /* Adjust width */
           padding: 25px;
           max-width: 700px; /* Limit width on medium screens */
       }
       header h1 { font-size: 1.9em; }
       #update { font-size: 0.9em; }
       .controls { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; }
       .btn { font-size: 1.05em; padding: 14px 20px; }
       #output li { font-size: 1.05em; padding: 15px 18px; }
       #btnRefresh { width: 60px; height: 60px; font-size: 1.8em; }
       #refresh-container { bottom: 25px; }
   }
    @media (max-width: 600px) {
       body { padding-top: 70px; padding-bottom: 80px; }
       #root {
           width: 95%; /* Near full width on mobile */
           padding: 20px;
           border-radius: 12px;
           margin: 10px auto;
       }
       header h1 { font-size: 1.7em; }
       #update { font-size: 0.85em; }
       .controls { grid-template-columns: 1fr 1fr; gap: 12px; }
       .btn { font-size: 1em; padding: 12px 15px; }
       #output li { font-size: 1em; padding: 12px 15px; }
       #btnRefresh { width: 55px; height: 55px; font-size: 1.6em; }
       #refresh-container { bottom: 20px; }
   }
    @media (max-width: 400px) {
       body { padding-top: 65px; padding-bottom: 75px; }
       header h1 { font-size: 1.5em; }
       #update { font-size: 0.8em; }
       .btn { font-size: 0.95em; padding: 11px 13px; }
        #output li { font-size: 0.95em; padding: 11px 13px; }
       #btnRefresh { width: 50px; height: 50px; font-size: 1.5em; }
       #refresh-container { bottom: 15px; }
   }

     /* SweetAlert Dark Theme Adjustments */
     body.swal2-shown > [aria-hidden="true"] {
       filter: blur(3px); /* Blur background when modal is open */
     }
     .swal2-popup {
       background: var(--secondary-bg) !important;
       color: var(--text-color) !important;
       border-radius: 10px !important;
       border: 1px solid var(--border-color);
       box-shadow: 0 5px 15px rgba(0,0,0,0.5) !important;
     }
     .swal2-title {
       color: var(--text-color) !important;
     }
     .swal2-html-container {
        color: var(--text-color-secondary) !important;
     }
     .swal2-input, .swal2-select {
       background: var(--primary-bg) !important;
       color: var(--text-color) !important;
       border: 1px solid var(--border-color) !important;
     }
      .swal2-input::placeholder { color: var(--text-color-secondary) !important; }
     .swal2-confirm {
       background: var(--button-bg) !important;
       background-image: var(--button-bg) !important; /* Ensure gradient applies */
       color: var(--button-text) !important;
       border-radius: 20px !important;
       padding: 10px 25px !important;
        transition: filter 0.2s ease !important;
        border: none !important;
     }
     .swal2-confirm:hover {
        filter: brightness(1.15) !important;
     }
     .swal2-cancel {
       background-color: #555 !important;
       color: var(--button-text) !important;
        border-radius: 20px !important;
        padding: 10px 25px !important;
        transition: background-color 0.3s ease !important;
        border: none !important;
     }
      .swal2-cancel:hover {
         background-color: #666 !important;
       }
      .swal2-loader {
         border-color: var(--loading-color) transparent var(--loading-color) transparent !important;
      }
      .swal2-success-ring {
        border-color: rgba(76, 175, 80, 0.7) !important; /* Slightly adjust success indicator */
      }

     /* Add Vazirmatn font */
     @font-face {
       font-family: 'Vazirmatn';
       src: url('https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/fonts/webfonts/Vazirmatn-Regular.woff2') format('woff2');
       font-weight: normal;
       font-style: normal;
       font-display: swap;
     }
     @font-face {
       font-family: 'Vazirmatn';
       src: url('https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/fonts/webfonts/Vazirmatn-Bold.woff2') format('woff2');
       font-weight: bold;
       font-style: normal;
       font-display: swap;
    }
  </style>
</head>
<body>
  <header>
    <h1>💵 Chand 💵</h1>
    <p id="update">در حال بارگذاری تاریخ...</p>
  </header>

  <div id="root">
    <div class="controls">
      <button class="btn" id="btnCurrency">ارزها 💵</button>
      <button class="btn" id="btnGold">قیمت طلا 🪙</button>
      <button class="btn" id="btnCoin">قیمت سکه 💰</button>
      <button class="btn" id="btnConvert">تبدیل ارز 💱</button>
    </div>
    <div id="output">
      <p style="text-align: center; color: var(--text-color-secondary);">برای مشاهده قیمت‌ها، یکی از دکمه‌های بالا را انتخاب کنید.</p>
    </div>
  </div>

  <!-- Refresh Button Container Added at the end -->
  <div id="refresh-container">
    <button class="btn" id="btnRefresh" title="رفرش و پاک کردن کش">🔄</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script>
    const chandeUrl = 'https://chande.net'; // Direct URL
    const tgjuBaseUrl = 'https://www.tgju.org/profile/'; // Direct URL
    const proxyUrl = 'https://cors-anywhere.herokuapp.com/'; // Proxy URL
    const DIRECT_FETCH_TIMEOUT_MS = 4500; // Timeout for direct fetch attempt (slightly less than 5s)
    const CACHE_DURATION_MINUTES = 5;
    const CACHE_PREFIX = 'chand_cache_';

    const currencies = [
      { code: 'usd', title: 'دلار آمریکا', unit: 'تومان', chandeCode: 'USD', tgjuProfile: 'price_dollar_rl' },
      { code: 'eur', title: 'یورو', unit: 'تومان', chandeCode: 'EUR' , tgjuProfile: 'price_eur'},
      { code: 'gbp', title: 'پوند انگلیس', unit: 'تومان', chandeCode: 'GBP', tgjuProfile: 'price_gbp' },
      { code: 'aed', title: 'درهم امارات', unit: 'تومان', chandeCode: 'AED', tgjuProfile: 'price_aed' }
    ];

    const additionalAssets = [
      { title: 'طلا 18 عیار', profile: 'geram18', unit: 'تومان', category: 'gold', needsTomanConversion: true },
      { title: 'انس جهانی طلا', profile: 'ons', unit: 'دلار', category: 'gold', needsTomanConversion: false },
      { title: 'مثقال طلا', profile: 'mesghal', unit: 'تومان', category: 'gold', needsTomanConversion: true },
      { title: 'طلای ۲۴ عیار', profile: 'geram24', unit: 'تومان', category: 'gold', needsTomanConversion: true },
      { title: 'سکه امامی', profile: 'sekee', unit: 'تومان', category: 'coin', needsTomanConversion: true },
      { title: 'نیم سکه', profile: 'nim', unit: 'تومان', category: 'coin', needsTomanConversion: true },
      { title: 'ربع سکه', profile: 'rob', unit: 'تومان', category: 'coin', needsTomanConversion: true },
      { title: 'سکه گرمی', profile: 'gerami', unit: 'تومان', category: 'coin', needsTomanConversion: true }
    ];

    const outputDiv = document.getElementById('output');
    const updateEl = document.getElementById('update');
    const refreshButton = document.getElementById('btnRefresh');
    let conversionRatesPromise = null;
    let lastFetchedCategory = null;

    // --- Caching Functions ---
    function saveToCache(key, data) {
        try {
            const cacheEntry = {
                timestamp: Date.now(),
                data: data
            };
            localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(cacheEntry));
        } catch (e) {
            console.error("Error saving to localStorage", e);
        }
    }

    function loadFromCache(key, maxAgeMinutes = CACHE_DURATION_MINUTES) {
        try {
            const item = localStorage.getItem(CACHE_PREFIX + key);
            if (!item) return null;
            const cacheEntry = JSON.parse(item);
            const ageMillis = Date.now() - cacheEntry.timestamp;
            if (ageMillis > maxAgeMinutes * 60 * 1000) {
                localStorage.removeItem(CACHE_PREFIX + key);
                return null;
            }
            console.log(`Using cached data for ${key}`);
            return cacheEntry.data;
        } catch (e) {
            console.error("Error loading from localStorage", e);
            return null;
        }
    }

     function clearCache(...keys) {
         console.log("Clearing cache for keys:", keys);
         keys.forEach(key => {
             try {
                 localStorage.removeItem(CACHE_PREFIX + key);
             } catch (e) {
                 console.error(`Error removing ${key} from localStorage`, e);
             }
         });
     }

    // --- Helper Functions ---

    function convertToToman(price) {
      return typeof price === 'number' && !isNaN(price) ? price / 10 : price;
    }

    function formatPrice(price, unit = 'تومان') {
      if (price === 'error' || price === null || typeof price === 'undefined' || isNaN(price)) {
        return `<span class="error">خطا در دریافت</span>`;
      }
      const number = Number(price);
      if (isNaN(number)) {
        return `<span class="error">نامعتبر</span>`;
      }
      return `${number.toLocaleString('fa-IR')} ${unit}`;
    }

    // Extracts plain text from the list item's HTML for copying
    function getPlainText(htmlString) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlString;
      return tempDiv.textContent || tempDiv.innerText || "";
    }

    function showLoading() {
      outputDiv.innerHTML = '<div class="loader"></div><p style="text-align:center; color: var(--text-color-secondary);">در حال بارگذاری...</p>';
    }

    function showOutput(items) {
      outputDiv.innerHTML = ''; // Clear previous content
      if (!items || items.length === 0) {
        outputDiv.innerHTML = '<p style="text-align:center; color: var(--text-color-secondary);">داده‌ای برای نمایش وجود ندارد.</p>';
        return;
      }
      const ul = document.createElement('ul');
      items.forEach((item, index) => { // Add index for animation delay
        const li = document.createElement('li');
        li.innerHTML = item.label;
        li.style.animationDelay = `${index * 0.05}s`; // Apply staggered delay

        if (item.label.includes('error') || item.label.includes('خطا') || item.label.includes('نامعتبر')) {
          li.classList.add('error');
        } else {
          // Add click listener only for valid items
          li.addEventListener('click', () => handleItemClick(li));
        }
        ul.appendChild(li);
      });
      outputDiv.appendChild(ul);
    }

    // Function to handle clicking on a list item for copying
    async function handleItemClick(listItem) {
      const textToCopy = getPlainText(listItem.innerHTML);
      if (!textToCopy || !navigator.clipboard) {
        Swal.fire('خطا', 'امکان کپی کردن وجود ندارد.', 'error');
        return;
      }

      try {
        const result = await Swal.fire({
          title: 'کپی در کلیپ‌بورد',
          html: `آیا مایل به کپی کردن متن زیر هستید؟<br><strong style="color: var(--link-color); display: block; margin-top: 10px; direction: ltr; text-align: center;">${textToCopy}</strong>`,
          icon: 'question',
          showCancelButton: true,
          confirmButtonText: 'بله، کپی کن',
          cancelButtonText: 'انصراف',
          reverseButtons: true
        });

        if (result.isConfirmed) {
          await navigator.clipboard.writeText(textToCopy);
          Swal.fire({
            title: 'کپی شد!',
            text: 'متن با موفقیت در کلیپ‌بورد کپی شد.',
            icon: 'success',
            timer: 1500, // Auto-close timer
            showConfirmButton: false
          });
        }
      } catch (err) {
        console.error('Failed to copy: ', err);
        Swal.fire('خطا', 'کپی کردن متن با مشکل مواجه شد.', 'error');
      }
    }

    // --- New Guarded Fetching Logic ---

    // Basic fetch function (used by guardedFetch)
    async function baseFetch(url, options, timeout = 15000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        try {
            const response = await fetch(url, { ...options, signal: controller.signal });
            clearTimeout(id);
            return response;
        } catch (error) {
            clearTimeout(id);
            throw error; // Re-throw error to be caught by caller
        }
    }

    // Tries direct fetch first, falls back to proxy
    async function fetchDataGuarded(directUrl, options = {}, timeout = 15000) {
        const proxyUrlResolved = proxyUrl + directUrl; // Construct proxy URL
        let response;
        let fetchMethod = 'direct'; // Track which method succeeded

        // 1. Try Direct Fetch with Timeout
        try {
            console.log(`Attempting direct fetch: ${directUrl}`);
            const directPromise = baseFetch(directUrl, options, DIRECT_FETCH_TIMEOUT_MS);
            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Direct fetch timeout')), DIRECT_FETCH_TIMEOUT_MS)
            );

            // Race direct fetch against timeout
            response = await Promise.race([directPromise, timeoutPromise]);

            // If direct fetch succeeded (check .ok)
            if (response.ok) {
                console.log(`Direct fetch succeeded: ${directUrl}`);
                // Proceed to read data
            } else {
                 // Direct fetch responded but with an error (e.g., 4xx, 5xx, but NOT CORS error which throws)
                 console.warn(`Direct fetch failed with status ${response.status}: ${directUrl}`);
                 throw new Error(`Direct fetch failed: ${response.status}`); // Trigger fallback
             }

        } catch (error) {
            // This catches: Network errors, CORS errors (TypeError), Timeout errors
            console.warn(`Direct fetch failed or timed out for ${directUrl}:`, error.message);
            console.log(`Falling back to proxy: ${proxyUrlResolved}`);
            fetchMethod = 'proxy';
            try {
                // 2. Fallback to Proxy Fetch
                response = await baseFetch(proxyUrlResolved, options, timeout); // Use the main timeout for proxy
                 if (!response.ok) {
                     // Handle potential proxy errors (like 403 Forbidden if proxy needs activation)
                      if (response.status === 403) {
                         // Handle CORS proxy activation prompt if necessary
                         let corsProxyActivated = sessionStorage.getItem('corsProxyActivated');
                         if (!corsProxyActivated) {
                             await promptActivateProxy(); // Assuming promptActivateProxy exists
                              // Indicate activation needed, caller should handle this
                              return { error: true, status: 'cors_proxy_activation_needed', data: null, method: fetchMethod };
                          } else {
                             console.error('CORS Proxy access likely expired or failed after activation.');
                             return { error: true, status: response.status, data: null, method: fetchMethod, corsExpired: true };
                         }
                      }
                     // Other proxy errors
                     console.error(`Proxy fetch failed with status ${response.status}: ${proxyUrlResolved}`);
                     throw new Error(`Proxy fetch failed: ${response.status}`);
                  }
                  console.log(`Proxy fetch succeeded: ${proxyUrlResolved}`);
            } catch (proxyError) {
                console.error(`Proxy fetch also failed for ${proxyUrlResolved}:`, proxyError);
                 // Both direct and proxy failed
                 return { error: true, status: proxyError.name === 'AbortError' ? 'timeout' : 'network_error', data: null, method: fetchMethod };
             }
        }

        // 3. Process Successful Response (either direct or proxy)
        try {
            const textData = await response.text();
            return { error: false, data: textData, method: fetchMethod }; // Include method info
        } catch (textError) {
            console.error(`Error reading response text from ${fetchMethod} fetch:`, textError);
             return { error: true, status: 'read_error', data: null, method: fetchMethod };
        }
    }

     // CORS Activation Prompt Function (kept from previous version)
     async function promptActivateProxy() {
         const result = await Swal.fire({
             title: 'فعال‌سازی دسترسی',
             html: `برای دریافت قیمت‌ها، نیاز به فعال‌سازی دسترسی به سرور کمکی (CORS Proxy) است.<br>لطفا روی دکمه زیر کلیک کنید و سپس دکمه "Request temporary access to the demo server" را در صفحه باز شده بزنید و به این صفحه برگردید.`,
             icon: 'info',
             confirmButtonText: 'فعال‌سازی دسترسی',
             showCancelButton: true,
             cancelButtonText: 'انصراف',
             allowOutsideClick: false
         });
         if (result.isConfirmed) {
             window.open(proxyUrl + 'corsdemo', '_blank'); // Use proxyUrl variable
             sessionStorage.setItem('corsProxyActivated', 'true');
             Swal.fire('دسترسی فعال شد!', 'لطفا دوباره دکمه دریافت قیمت را بزنید.', 'success');
             return true;
         }
         return false;
     }


    // --- Fetching Specific Prices (Using fetchDataGuarded) ---

    async function fetchPriceFromChande(currencyCode, forceRefresh = false) {
        const cacheKey = `chande_${currencyCode}`;
        if (!forceRefresh) {
            const cachedData = loadFromCache(cacheKey);
            if (cachedData !== null) return cachedData;
        }

        const directUrl = `${chandeUrl}`; // Chande doesn't need specific path for main page
        const result = await fetchDataGuarded(directUrl);

        if (result.error) {
            saveToCache(cacheKey, 'error');
            return result.status === 'cors_proxy_activation_needed' ? 'cors_activation' : 'error';
        }

        try {
            const html = result.data;
            const regex = new RegExp(`<th[^>]*>\s*${currencyCode}\s*<\/th>.*?<td[^>]*>\s*([\d,.]+)\s*<\/td>`, 'is');
            const match = html.match(regex);
            const price = match && match[1] ? parseInt(match[1].replace(/,/g, '')) : 'error';
            saveToCache(cacheKey, price);
            console.log(`Fetched ${currencyCode} via ${result.method}`);
            return price;
        } catch (e) {
            console.error(`Error parsing Chande.net HTML for ${currencyCode}:`, e);
            saveToCache(cacheKey, 'error');
            return 'error';
        }
    }

    async function fetchPriceFromTGJU(profile, forceRefresh = false) {
        const cacheKey = `tgju_${profile}`;
        if (!forceRefresh) {
            const cachedData = loadFromCache(cacheKey);
            if (cachedData !== null) return cachedData;
        }

        const directUrl = `${tgjuBaseUrl}${profile}`;
        const result = await fetchDataGuarded(directUrl);

        if (result.error) {
             saveToCache(cacheKey, 'error');
             if (result.status === 'cors_proxy_activation_needed') return 'cors_activation';
             if (result.corsExpired) console.warn(`Skipping TGJU fetch for ${profile} due to potential expired CORS proxy.`);
             return 'error';
         }

        try {
            const html = result.data;
            const regex = /<td\s+class="text-left"[^>]*>\s*([\d,.]+)\s*<\/td>/i;
            const match = html.match(regex);
            const price = match && match[1] ? parseFloat(match[1].replace(/,/g, '')) : 'error';
            saveToCache(cacheKey, price);
            console.log(`Fetched ${profile} via ${result.method}`);
            return price;
        } catch (e) {
            console.error(`Error parsing TGJU HTML for ${profile}:`, e);
            saveToCache(cacheKey, 'error');
            return 'error';
        }
    }

    // --- Aggregate Fetching Functions (Using Promise.allSettled) ---

    async function fetchCurrencyPrices(forceRefresh = false) {
        const cacheKey = 'currency_prices';
        if (!forceRefresh) {
            const cachedData = loadFromCache(cacheKey);
            if (cachedData) return cachedData;
        }

        console.log(`Fetching currency prices... (Force refresh: ${forceRefresh})`);
        const promises = currencies.map(cur =>
            Promise.allSettled([
                fetchPriceFromChande(cur.chandeCode, forceRefresh),
                cur.tgjuProfile ? fetchPriceFromTGJU(cur.tgjuProfile, forceRefresh) : Promise.resolve('N/A') // Resolve immediately if no TGJU profile
            ]).then(results => ({ cur, results }))
        );

        const settledResults = await Promise.all(promises); // Wait for all currency pairs

        const finalResults = [];
        let corsPrompted = false;

        for (const { cur, results } of settledResults) {
            const [chandeResult, tgjuResult] = results;

            const priceChande = chandeResult.status === 'fulfilled' ? chandeResult.value : 'error';
            const priceTGJU = tgjuResult.status === 'fulfilled' ? tgjuResult.value : 'error';

            if (priceChande === 'cors_activation' || priceTGJU === 'cors_activation') {
                corsPrompted = true;
                break; // Stop processing if CORS activation needed
            }

            finalResults.push({ label: `${cur.title} (نرخ 1 - Chande): ${formatPrice(priceChande, cur.unit)}` });
            if (cur.tgjuProfile) {
                 // Handle N/A case for TGJU specifically if it wasn't fetched
                 const formattedTgju = priceTGJU === 'N/A' ? '<span class="error">ندارد</span>' : formatPrice((priceTGJU !== 'error' ? convertToToman(priceTGJU) : 'error'), cur.unit);
                 finalResults.push({ label: `${cur.title} (نرخ 2 - TGJU): ${formattedTgju}` });
            }
        }

        if (corsPrompted) return null;
        saveToCache(cacheKey, finalResults);
        return finalResults;
    }

    async function fetchCurrencyRatesForConversion(forceRefresh = false) {
        const cacheKey = 'conversion_rates';
        if (!forceRefresh) {
            const cachedData = loadFromCache(cacheKey);
            if (cachedData && cachedData.error === null) {
                console.log("Using cached conversion rates.");
                return cachedData;
            }
        }

        console.log(`Fetching conversion rates... (Force refresh: ${forceRefresh})`);
        const promises = currencies.map(cur =>
            fetchPriceFromChande(cur.chandeCode, forceRefresh)
                .then(price => ({ code: cur.code, price })) // Return object with code and price/error
        );

        const settledResults = await Promise.allSettled(promises);

        const rates = {};
        let corsPrompted = false;
        let fetchSucceeded = false;

        for (const result of settledResults) {
            if (result.status === 'fulfilled') {
                const { code, price } = result.value;
                if (price === 'cors_activation') {
                    corsPrompted = true;
                    break;
                }
                if (price !== 'error') {
                    rates[code] = price;
                    fetchSucceeded = true;
                } else {
                    rates[code] = null;
                }
            } else {
                 // Handle case where the fetch promise itself was rejected (less likely now)
                 console.error("Error in fetchCurrencyRatesForConversion promise:", result.reason);
                 // Potentially find code based on result.reason if needed, or mark all as potentially failed
             }
        }

        let finalResult;
        if (corsPrompted) {
            finalResult = { rates: null, error: 'cors_activation' };
        } else if (!fetchSucceeded) {
            finalResult = { rates: null, error: 'fetch_failed' };
        } else {
            finalResult = { rates: rates, error: null };
        }
        saveToCache(cacheKey, finalResult);
        console.log("Conversion rates fetch complete:", finalResult);
        return finalResult;
    }

    async function fetchAssetPrices(category, forceRefresh = false) {
        const cacheKey = `${category}_prices`;
        if (!forceRefresh) {
            const cachedData = loadFromCache(cacheKey);
            if (cachedData) return cachedData;
        }

        console.log(`Fetching ${category} prices... (Force refresh: ${forceRefresh})`);
        const assets = additionalAssets.filter(a => a.category === category);
        const promises = assets.map(asset =>
            fetchPriceFromTGJU(asset.profile, forceRefresh)
                .then(price => ({ asset, price }))
        );

        const settledResults = await Promise.allSettled(promises);

        const finalResults = [];
        let corsPrompted = false;

        for (const result of settledResults) {
            if (result.status === 'fulfilled') {
                const { asset, price } = result.value;
                if (price === 'cors_activation') {
                    corsPrompted = true;
                    break;
                }
                let displayPrice = price;
                if (asset.needsTomanConversion && price !== 'error') {
                    displayPrice = convertToToman(price);
                }
                finalResults.push({ label: `${asset.title}: ${formatPrice(displayPrice, asset.unit)}` });
            } else {
                 console.error(`Error fetching asset price ${result.reason?.message || ''}:`, result.reason);
                 // Find asset based on promise if possible, or add a generic error line
                 // For simplicity, we might just skip adding a line for rejected fetches here
                 // Or find the asset based on profile name if the error object contains it (depends on implementation)
                 // finalResults.push({ label: `خطا در دریافت قیمت (${category})` });
             }
        }

        if (corsPrompted) return null;
        saveToCache(cacheKey, finalResults);
        return finalResults;
    }

    // --- Trigger Fetch Function (remains largely the same, relies on updated fetchers) ---
    async function triggerFetch(category, forceRefresh = false) {
        lastFetchedCategory = category;
        showLoading();
        let dataPromise;
        switch (category) {
            case 'currency': dataPromise = fetchCurrencyPrices(forceRefresh); break;
            case 'gold': dataPromise = fetchAssetPrices('gold', forceRefresh); break;
            case 'coin': dataPromise = fetchAssetPrices('coin', forceRefresh); break;
            default:
                console.error("Invalid category:", category);
                outputDiv.innerHTML = '<p style="text-align:center; color: var(--error-color);">خطای داخلی: دسته نامعتبر.</p>';
                return Promise.reject("Invalid category");
        }

        try {
            const data = await dataPromise;
            if (data === null && sessionStorage.getItem('corsProxyActivated')) { // Check if CORS was prompted
                outputDiv.innerHTML = '<p style="text-align:center; color: var(--text-color-secondary);">لطفا پس از فعال‌سازی دسترسی، دوباره تلاش کنید.</p>';
                return;
            }
            if (data === null && !sessionStorage.getItem('corsProxyActivated')){
                 // Handle case where CORS prompt was needed but not yet confirmed by user
                 // The promptActivateProxy function handles showing the initial Swal message
                 outputDiv.innerHTML = '<p style="text-align:center; color: var(--text-color-secondary);">نیاز به فعال‌سازی دسترسی به سرور کمکی.</p>';
                 return;
             }
            showOutput(data);
        } catch (error) {
            console.error(`Error triggering fetch for ${category}:`, error);
            outputDiv.innerHTML = `<p style="text-align:center; color: var(--error-color);">خطا در بارگذاری داده‌های ${category}.</p>`;
            // Don't re-throw here unless needed elsewhere
        }
    }

    // --- Event Listeners (Refresh button needs slight modification for async triggerFetch) ---

    document.getElementById('btnCurrency').addEventListener('click', () => triggerFetch('currency'));
    document.getElementById('btnGold').addEventListener('click', () => triggerFetch('gold'));
    document.getElementById('btnCoin').addEventListener('click', () => triggerFetch('coin'));

    refreshButton.addEventListener('click', async () => {
        console.log("Refresh button clicked.");
        if (refreshButton.classList.contains('loading')) return;

        refreshButton.classList.add('loading');
        refreshButton.disabled = true;

        clearCache('currency_prices', 'gold_prices', 'coin_prices', 'conversion_rates');
        currencies.forEach(c => clearCache(`chande_${c.chandeCode}`, `tgju_${c.tgjuProfile}`));
        additionalAssets.forEach(a => clearCache(`tgju_${a.profile}`));

        // Force refresh conversion rates in the background
        conversionRatesPromise = fetchCurrencyRatesForConversion(true);
        conversionRatesPromise.catch(err => { console.error("Error during refresh pre-fetch:", err); });

        try {
            if (lastFetchedCategory) {
                console.log("Refreshing last category:", lastFetchedCategory);
                await triggerFetch(lastFetchedCategory, true); // Await completion
            } else {
                outputDiv.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary);">کش پاک شد. یک دسته را برای دریافت قیمت‌های جدید انتخاب کنید.</p>';
            }
            Swal.fire({
                icon: 'success',
                title: 'رفرش شد',
                text: 'حافظه پنهان پاک شد و درخواست داده‌های جدید ارسال گردید.',
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 2500,
                timerProgressBar: true
            });
        } catch (error) {
            console.error("Error during refresh fetch:", error);
            Swal.fire({
                icon: 'error',
                title: 'خطا در رفرش',
                text: 'مشکلی در دریافت داده‌های جدید رخ داد.',
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
        } finally {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
        }
    });

    // ... (Conversion Button Logic remains the same, relies on updated conversionRatesPromise) ...
    document.getElementById('btnConvert').addEventListener('click', async () => {
      if (!conversionRatesPromise) {
        console.error("Conversion rates promise not initialized!");
        Swal.fire('خطا', 'در حال آماده‌سازی نرخ‌ها، لطفا چند لحظه صبر کنید و دوباره تلاش کنید.', 'warning');
        return;
      }
      const currencyOptions = currencies.reduce((acc, cur) => {
        acc[cur.code] = `${cur.title} (${cur.code.toUpperCase()})`;
        return acc;
      }, {});
      const { value: formValues } = await Swal.fire({
        title: 'تبدیل ارز 💱',
        html:
          `<label for="swal-input-amount" style="display: block; text-align: right; margin-bottom: 5px;">مقدار:</label>` +
          '<input id="swal-input-amount" class="swal2-input" placeholder="مقدار عددی وارد کنید" type="number" min="0" style="width: 95%; margin-bottom: 10px;">' +
          `<label for="swal-select-source" style="display: block; text-align: right; margin-bottom: 5px;">از ارز:</label>` +
          '<select id="swal-select-source" class="swal2-select" style="width: 95%; margin-bottom: 10px;"></select>' +
          `<label for="swal-select-target" style="display: block; text-align: right; margin-bottom: 5px;">به ارز:</label>` +
          '<select id="swal-select-target" class="swal2-select" style="width: 95%;"></select>',
        focusConfirm: false,
        confirmButtonText: 'محاسبه',
        showCancelButton: true,
        cancelButtonText: 'انصراف',
        showLoaderOnConfirm: true,
        didOpen: () => {
          const sourceSelect = document.getElementById('swal-select-source');
          const targetSelect = document.getElementById('swal-select-target');
          for (const code in currencyOptions) {
            sourceSelect.add(new Option(currencyOptions[code], code));
            targetSelect.add(new Option(currencyOptions[code], code));
          }
          sourceSelect.value = 'usd';
          targetSelect.value = 'eur';
          document.getElementById('swal-input-amount').onkeyup = (event) => event.key === 'Enter' && Swal.clickConfirm();
        },
        preConfirm: async () => {
          const amount = document.getElementById('swal-input-amount').value;
          const source = document.getElementById('swal-select-source').value;
          const target = document.getElementById('swal-select-target').value;
          const numericAmount = parseFloat(amount);
          if (isNaN(numericAmount) || numericAmount <= 0 || !source || !target) {
            Swal.showValidationMessage('لطفاً مقدار عددی معتبر و هر دو ارز را انتخاب کنید.');
            return false;
          }
          try {
            const ratesResult = await conversionRatesPromise;
            if (ratesResult.error === 'cors_activation') {
              Swal.showValidationMessage('لطفا ابتدا دسترسی به سرور کمکی را فعال کرده و دوباره امتحان کنید.');
              return false;
            }
            if (ratesResult.error || !ratesResult.rates) {
              Swal.showValidationMessage('خطا در دریافت نرخ‌ها. لطفا بعدا تلاش کنید.');
              return false;
            }
            const rates = ratesResult.rates;
            if (rates[source] === null || rates[target] === null) {
              Swal.showValidationMessage('نرخ ارز مورد نظر دریافت نشد.');
              return false;
            }
            if (rates[target] === 0) {
              Swal.showValidationMessage('نرخ ارز مقصد صفر است.');
              return false;
            }
            const result = (numericAmount * rates[source]) / rates[target];
            return { amount: numericAmount, source, target, result };
          } catch (error) {
            console.error("Error during preConfirm rate fetching:", error);
            Swal.showValidationMessage('خطای غیرمنتظره در دریافت نرخ‌ها.');
            return false;
          }
        }
      });
      if (formValues) {
        const { amount, source, target, result } = formValues;
        const targetCurrencyInfo = currencies.find(c => c.code === target);
        const sourceCurrencyInfo = currencies.find(c => c.code === source);
        const formattedAmount = amount.toLocaleString('fa-IR');
        const formattedResult = result.toLocaleString('fa-IR', { maximumFractionDigits: 2 });
        Swal.fire({
          icon: 'success',
          title: 'نتیجه تبدیل',
          html: `
            <div style="text-align: center; font-size: 1.1em; margin-top: 15px;">
              <strong>${formattedAmount}</strong> ${sourceCurrencyInfo?.title || source.toUpperCase()}
              <br>برابر است با<br>
              <strong>${formattedResult}</strong> ${targetCurrencyInfo?.title || target.toUpperCase()}
            </div>
          `,
          confirmButtonText: 'فهمیدم'
        });
      }
    });

    // ... (Date/Time Update Logic remains the same) ...
    function updateDateTime() {
      try {
        const now = new Date();
        const persianDate = now.toLocaleDateString('fa-IR-u-nu-latn', {
          timeZone: 'Asia/Tehran', year: 'numeric', month: 'long', day: 'numeric'
        });
        const time = now.toLocaleTimeString('fa-IR-u-nu-latn', {
          timeZone: 'Asia/Tehran', hour: '2-digit', minute: '2-digit', hour12: false
        });
        updateEl.textContent = `آخرین بروزرسانی: ${persianDate} - ${time}`;
      } catch (e) {
        console.error("Error updating date/time:", e);
        updateEl.textContent = "خطا در بروزرسانی زمان";
      }
    }

    // ... (Initialization Logic remains the same) ...
    function initializeApp() {
      updateDateTime();
      setInterval(updateDateTime, 30000);
      conversionRatesPromise = fetchCurrencyRatesForConversion();
      conversionRatesPromise.catch(err => {
        console.error("Error during initial conversion rate pre-fetch:", err);
      });
      console.log("Chand Web App Initialized (Dark Mode, Optimized with Cache, Parallel Fetch).");
    }
    document.addEventListener('DOMContentLoaded', initializeApp);

  </script>
</body>
</html>
